#!/usr/bin/env bash
# shellcheck disable=SC1091		# See https://www.shellcheck.net/wiki/SC1091
# Bash extension
# Wanted to leave the default .bashrc file and keep all custom stuff here
# Didn't want to bother with the .bash_profile v .bashrc so keeping all in this file at this time, See http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html
set -u


# Functions
calc-dir-md5sum() { find "${1}" -type f -exec md5sum {} \; | sort -k 2,2 -V | cut -d ' ' -f 1 | md5sum | cut -d ' ' -f 1; }

configure-tool() {
	# If tool exists ${1} then configure based on remaining args
	# shellcheck disable=SC2294 # See https://www.shellcheck.net/wiki/SC2294
	[ -n "$(which "${1}")" ] && shift && eval "$@"
}

decode-epoch() { date -d @"${1}"; }

decode-jwt() {
	# See https://gist.github.com/angelo-v/e0208a18d455e2e6ea3c40ad637aac53#gistcomment-3920605
	#	  https://datatracker.ietf.org/doc/html/rfc7519
	jq -R 'split(".") | select(length > 0) | .[0],.[1] | @base64d | fromjson' <<< "${1}"
}

ensure-asdf-plugins-installed() {
	file_path=${1:-${HOME}/.tool-versions}
	awk '$1 != "#" { print $1 }' "${file_path}" | xargs -n 1 asdf plugin add
}

ensure-on-path() {
	candidate_path=${1}
	[[ -d ${candidate_path} && ${PATH} != *${candidate_path}* ]] && export PATH=${PATH}:${candidate_path}
}

get-git-prompt-info() {
	# Blatant copy of https://github.com/jfrazelle/dotfiles/blob/master/.bash_prompt
	local s=''
	local branch_name=''

	# Check if the current directory is in a Git repository.
	if [ "$(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}")" == '0' ]; then
		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
			# Check for uncommitted changes in the index.
			if ! git diff --quiet --ignore-submodules --cached; then s+='+'; fi

			# Check for unstaged changes.
			if ! git diff-files --quiet --ignore-submodules --; then s+='!'; fi

			# Check for untracked files.
			if [ -n "$(git ls-files --others --exclude-standard)" ]; then s+='?'; fi

			# Check for stashed files.
			if git rev-parse --verify refs/stash &>/dev/null; then s+='$'; fi
		fi

		# Get the short symbolic ref.
		# If HEAD isnâ€™t a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branch_name="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
			git rev-parse --short HEAD 2> /dev/null || \
			echo '(unknown)')"

		[ -n "${s}" ] && s=" [${s}]"
		echo -e "${branch_name}${s} "
	else
		return;
	fi
}

get-latest-github-release() {
	# See https://developer.github.com/v3/repos/releases/#get-the-latest-release
	# Subject to rate limiting
	: "${1?"Need an org"}"
	: "${2?"Need an repo"}"
	org=${1}
	repo=${2}

	curl -sL "https://api.github.com/repos/${org}/${repo}/releases/latest" | jq -r .tarball_url | xargs basename | sed 's/^v//'
}

install-asdf() {
	# See https://asdf-vm.com/#/core-manage-asdf
	# Just for initial install, can then use asdf to manage its own updates
	# We do NOT automatically install - you need to invoke this function
	version=$(get-latest-github-release asdf-vm asdf)
	git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch "v${version}"
}

list-asdf-plugin-update-candidates() {
	# Subject to github rate limiting - since most are on github.com
	file_path=${1:-${HOME}/.tool-versions}

	while read -r plugin; do
		current=$(awk '$1=="'"${plugin}"'" {print $2}' "${file_path}")
		latest=$(asdf latest "${plugin}" 2> /dev/null || echo '')
		[[ ${latest} == '' || ${latest} == "${current}" ]] && continue

		echo "Can bump ${plugin}: ${current} to ${latest}"
	done < <(awk '$1 != "#" { print $1 }' "${file_path}")
}

list-function-names() { declare -F | awk '$3 !~ /^_/ { print $3 }'; }

re-source-dot() { . "${HOME}/.bashrc"; }

update-asdf-plugin-versions() {
	# Subject to github rate limiting - since most are on github.com
	file_path=${1:-${HOME}/.tool-versions}
	while read -r plugin; do
		current=$(awk '$1=="'"${plugin}"'" {print $2}' "${file_path}")
		latest=$(asdf latest "${plugin}" 2> /dev/null || echo '')
		[[ ${latest} == '' || ${latest} == "${current}" ]] && continue

		echo "Bumping ${plugin}: ${current} to ${latest}"
		sed -i "s/^${plugin} .*/${plugin} ${latest}/" "${file_path}"
	done < <(awk '$1 != "#" { print $1 }' "${file_path}")
	echo -e "\nWill need to run asdf install to get the new versions"
}

update-eks-kubeconfig() {
	: "${1?"Need a cluster name, as appears in: aws eks list-clusters"}"
	cluster_name=${1}

	# Will create a file in ~/.kube directory
	# Assumes
	#   Cluster names are unique across AWS accounts if dealing with multiple AWS accounts
	#   We are using a profile with a region already configured
	aws eks update-kubeconfig --name "${cluster_name}" --kubeconfig "${HOME}/.kube/${cluster_name}.config"
}


# Configuration
## Environment
# Prompt - will assume we have colour and just append the git info if in a git repo
# shellcheck disable=SC2154 # See https://www.shellcheck.net/wiki/SC2154
export PS1="\${debian_chroot:+(\${debian_chroot})}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\] \$(get-git-prompt-info)\$ "

# Use vim as editor - in particular for git, see https://stackoverflow.com/questions/2596805/how-do-i-make-git-use-the-editor-of-my-choice-for-commits
export VISUAL=vim
export EDITOR=${VISUAL}

## Path
# Include user's private bin directory in PATH if it exists
ensure-on-path "${HOME}/bin"

## Tools - Lots of these are optionals
# asdf
# See https://asdf-vm.com/#/core-manage-asdf
if [[ -d ~/.asdf ]]; then
	. "${HOME}/.asdf/asdf.sh"
	. "${HOME}/.asdf/completions/asdf.bash"
fi

# AWS CLI shell autocompletion
configure-tool aws_completer "complete -C $(which aws_completer) aws"

# direnv
# See https://direnv.net/docs/hook.html
# Since using asdf - need to adapt
configure-tool direnv "$(asdf exec direnv hook bash)"

# kubectl shell autocompletion, see https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion
configure-tool kubectl 'source <(kubectl completion bash)'
configure-tool kubectl 'complete -o default -F __start_kubectl k'

# kubectl krew plugin manager
ensure-on-path "${HOME}/.krew/bin"

# Rust, see rustup at https://www.rust-lang.org/tools/install
# rustup might add this to ~/.profile also
ensure-on-path "${HOME}/.cargo/bin"


# Local extension that I do NOT want in this repo - different on each machine etc.
if [ -f "${HOME}/.bashrc_local_ext" ]; then . "${HOME}/.bashrc_local_ext"; fi
